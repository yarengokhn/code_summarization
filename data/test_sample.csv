code,summary
"def _load_file(filename):
     fp = open(filename, 'rb') 
      source = (fp.read() + '\n') 
      try: 
            co = compile(source, filename, 'exec') 
      except SyntaxError: 
            print >>sys.stderr, '>>Syntax      error      in', filename 
            raise 
      fp.close() 
      return co",'load a Python source file and compile it to byte-code   _load_module(filename: string): code_object   filename:   name of file containing Python source code   (normally a .py)   code_object: code_object compiled from this source code   This function does NOT write any file!'
"def _load_module(filename):
     import magics, marshal 
      fp = open(filename, 'rb') 
      magic = fp.read(4) 
      try: 
            version = magics.versions[magic] 
      except KeyError: 
            raise ImportError, ('Unknown      magic      number      %s      in      %s' % ((ord(magic[0]) + (256 * ord(magic[1]))), filename)) 
      if (version != '2.7'): 
            raise ImportError, ('This      is      a      Python      %s      file!      Only      Python      2.7      files      are      supported.' % version) 
      fp.read(4) 
      co = marshal.load(fp) 
      fp.close() 
      return (version, co)",'load a module without importing it   _load_module(filename: string): code_object   filename:   name of file containing Python byte-code object   (normally a .pyc)   code_object: code_object from this file'
"def uncompyle(version, co, out=None, showasm=0, showast=0, deob=0):
     assert (type(co) == types.CodeType) 
      __real_out = (out or sys.stdout) 
      if co.co_filename: 
            print >>__real_out, ('#Embedded      file      name:      %s' % co.co_filename) 
      scanner = Scanner.getscanner(version) 
      scanner.setShowAsm(showasm, out) 
      (tokens, customize) = scanner.disassemble(co, deob=deob) 
      walker = Walker.Walker(out, scanner, showast=showast) 
      try: 
            ast = walker.build_ast(tokens, customize) 
      except Walker.ParserError as e: 
            print >>__real_out, e 
            raise 
      del tokens 
      assert (ast == 'stmts') 
      try: 
            if (ast[0][0] == Walker.ASSIGN_DOC_STRING(co.co_consts[0])): 
                  walker.print_docstring('', co.co_consts[0]) 
                  del ast[0] 
            if (ast[(-1)] == Walker.RETURN_NONE): 
                  ast.pop() 
      except: 
            pass 
      walker.mod_globs = Walker.find_globals(ast, set()) 
      walker.gen_source(ast, customize) 
      for g in walker.mod_globs: 
            walker.write(('global      %s      ##      Warning:      Unused      global\n' % g)) 
      if walker.pending_newlines: 
            print >>__real_out 
      if walker.ERROR: 
            raise walker.ERROR",'diassembles a given code block \'co\''
"def uncompyle_file(filename, outstream=None, showasm=0, showast=0, deob=0):
     (version, co) = _load_module(filename) 
      uncompyle(version, co, outstream, showasm, showast, deob) 
      co = None",'decompile Python byte-code file (.pyc)'
"def main(in_base, out_base, files, codes, outfile=None, showasm=0, showast=0, do_verify=0, py=0, deob=0):
     def _get_outstream(outfile): 
            dir = os.path.dirname(outfile) 
            failed_file = (outfile + '_failed') 
            if os.path.exists(failed_file): 
                  os.remove(failed_file) 
            try: 
                  os.makedirs(dir) 
            except OSError: 
                  pass 
            return open(outfile, 'w') 
      of = outfile 
      tot_files = okay_files = failed_files = verify_failed_files = 0 
      for code in codes: 
            version = sys.version[:3] 
            with open(code, 'r') as f: 
                  co = compile(f.read(), '', 'exec') 
            uncompyle(sys.version[:3], co, sys.stdout, showasm=showasm, showast=showast, deob=deob) 
      for file in files: 
            infile = os.path.join(in_base, file) 
            if of: 
                  outstream = _get_outstream(outfile) 
            elif (out_base is None): 
                  outstream = sys.stdout 
            else: 
                  outfile = os.path.join(out_base, file) 
                  if py: 
                        outfile = outfile[:(-1)] 
                  else: 
                        outfile += '_dis' 
                  outstream = _get_outstream(outfile) 
            try: 
                  uncompyle_file(infile, outstream, showasm, showast, deob) 
                  tot_files += 1 
            except KeyboardInterrupt: 
                  if outfile: 
                        outstream.close() 
                        os.remove(outfile) 
                  raise 
            except: 
                  failed_files += 1 
                  sys.stderr.write((""###      Can't      uncompyle      %s\n"" % infile)) 
                  if outfile: 
                        outstream.close() 
                        os.rename(outfile, (outfile + '_failed')) 
                  import traceback 
                  traceback.print_exc() 
            else: 
                  if outfile: 
                        outstream.close() 
                  if do_verify: 
                        try: 
                              verify.compare_code_with_srcfile(infile, outfile) 
                              print '+++      okay      decompyling', infile, __memUsage() 
                              okay_files += 1 
                        except verify.VerifyCmpError as e: 
                              verify_failed_files += 1 
                              os.rename(outfile, (outfile + '_unverified')) 
                              print >>sys.stderr, '###      Error      Verifiying', file 
                              print >>sys.stderr, e 
                  else: 
                        okay_files += 1 
                        print '+++      okay      decompyling', infile, __memUsage() 
      return (tot_files, okay_files, failed_files, verify_failed_files)","'in_base     base directory for input files   out_base    base directory for output files (ignored when   files       list of filenames to be uncompyled (relative to src_base)   outfile     write output to this filename (overwrites out_base)   For redirecting output to   - <filename>                outfile=<filename> (out_base is ignored)   - files below out_base      out_base=...   - stdout                    out_base=None, outfile=None'"
"def cmp_code_objects(version, code_obj1, code_obj2, name=''):
     assert (type(code_obj1) == types.CodeType) 
      assert (type(code_obj2) == types.CodeType) 
      if isinstance(code_obj1, object): 
            assert (dir(code_obj1) == dir(code_obj2)) 
      else: 
            assert (dir(code_obj1) == code_obj1.__members__) 
            assert (dir(code_obj2) == code_obj2.__members__) 
            assert (code_obj1.__members__ == code_obj2.__members__) 
      if (name == '__main__'): 
            name = code_obj1.co_name 
      else: 
            name = ('%s.%s' % (name, code_obj1.co_name)) 
            if (name == '.?'): 
                  name = '__main__' 
      if (isinstance(code_obj1, object) and cmp(code_obj1, code_obj2)): 
            pass 
      if isinstance(code_obj1, object): 
            members = filter((lambda x: x.startswith('co_')), dir(code_obj1)) 
      else: 
            members = dir(code_obj1) 
      members.sort() 
      tokens1 = None 
      for member in members: 
            if (member in __IGNORE_CODE_MEMBERS__): 
                  pass 
            elif (member == 'co_code'): 
                  scanner = Scanner.getscanner(version) 
                  scanner.setShowAsm(showasm=0) 
                  global JUMP_OPs 
                  JUMP_OPs = (scanner.JUMP_OPs + ['JUMP_BACK']) 
                  scanner.setTokenClass(Token) 
                  try: 
                        (tokens1, customize) = scanner.disassemble(code_obj1) 
                        del customize 
                        (tokens2, customize) = scanner.disassemble(code_obj2) 
                        del customize 
                  finally: 
                        scanner.resetTokenClass() 
                  targets1 = dis.findlabels(code_obj1.co_code) 
                  tokens1 = [t for t in tokens1 if (t.type != 'COME_FROM')] 
                  tokens2 = [t for t in tokens2 if (t.type != 'COME_FROM')] 
                  i1 = 0 
                  i2 = 0 
                  offset_map = {} 
                  check_jumps = {} 
                  while (i1 < len(tokens1)): 
                        if (i2 >= len(tokens2)): 
                              if ((len(tokens1) == (len(tokens2) + 2)) and (tokens1[(-1)].type == 'RETURN_VALUE') and (tokens1[(-2)].type == 'LOAD_CONST') and (tokens1[(-2)].pattr == None) and (tokens1[(-3)].type == 'RETURN_VALUE')): 
                                    break 
                              else: 
                                    raise CmpErrorCodeLen(name, tokens1, tokens2) 
                        offset_map[tokens1[i1].offset] = tokens2[i2].offset 
                        for (idx1, idx2, offset2) in check_jumps.get(tokens1[i1].offset, []): 
                              if (offset2 != tokens2[i2].offset): 
                                    raise CmpErrorCode(name, tokens1[idx1].offset, tokens1[idx1], tokens2[idx2], tokens1, tokens2) 
                        if (tokens1[i1] != tokens2[i2]): 
                              if (tokens1[i1].type == 'LOAD_CONST' == tokens2[i2].type): 
                                    i = 1 
                                    while (tokens1[(i1 + i)].type == 'LOAD_CONST'): 
                                          i += 1 
                                    if (tokens1[(i1 + i)].type.startswith(('BUILD_TUPLE', 'BUILD_LIST')) and (i == int(tokens1[(i1 + i)].type.split('_')[(-1)]))): 
                                          t = tuple([elem.pattr for elem in tokens1[i1:(i1 + i)]]) 
                                          if (t != tokens2[i2].pattr): 
                                                raise CmpErrorCode(name, tokens1[i1].offset, tokens1[i1], tokens2[i2], tokens1, tokens2) 
                                          i1 += (i + 1) 
                                          i2 += 1 
                                          continue 
                                    elif ((i == 2) and (tokens1[(i1 + i)].type == 'ROT_TWO') and (tokens2[(i2 + 1)].type == 'UNPACK_SEQUENCE_2')): 
                                          i1 += 3 
                                          i2 += 2 
                                          continue 
                                    elif ((i == 2) and (tokens1[(i1 + i)].type in BIN_OP_FUNCS)): 
                                          f = BIN_OP_FUNCS[tokens1[(i1 + i)].type] 
                                          if (f(tokens1[i1].pattr, tokens1[(i1 + 1)].pattr) == tokens2[i2].pattr): 
                                                i1 += 3 
                                                i2 += 1 
                                                continue 
                                    elif ((i == 1) and (tokens1[(i1 + i)].type == 'STORE_NAME' == tokens2[(i2 + i)].type) and (tokens1[(i1 + i)].pattr == '__doc__' == tokens2[(i2 + i)].pattr)): 
                                          i1 += 2 
                                          i2 += 2 
                                          continue 
                              elif (tokens1[i1].type == 'UNARY_NOT'): 
                                    if (tokens2[i2].type == 'POP_JUMP_IF_TRUE'): 
                                          if (tokens1[(i1 + 1)].type == 'POP_JUMP_IF_FALSE'): 
                                                i1 += 2 
                                                i2 += 1 
                                                continue 
                                    elif (tokens2[i2].type == 'POP_JUMP_IF_FALSE'): 
                                          if (tokens1[(i1 + 1)].type == 'POP_JUMP_IF_TRUE'): 
                                                i1 += 2 
                                                i2 += 1 
                                                continue 
                              elif ((tokens1[i1].type in ('JUMP_FORWARD', 'JUMP_BACK')) and (tokens1[(i1 - 1)].type == 'RETURN_VALUE') and (tokens2[(i2 - 1)].type in ('RETURN_VALUE', 'RETURN_END_IF')) and (int(tokens1[i1].offset) not in targets1)): 
                                    i1 += 1 
                                    continue 
                              elif ((tokens1[i1].type == 'JUMP_FORWARD') and (tokens2[i2].type == 'JUMP_BACK') and (tokens1[(i1 + 1)].type == 'JUMP_BACK') and (tokens2[(i2 + 1)].type == 'JUMP_BACK') and (int(tokens1[i1].pattr) == (int(tokens1[i1].offset) + 3))): 
                                    if (int(tokens1[i1].pattr) == int(tokens1[(i1 + 1)].offset)): 
                                          i1 += 2 
                                          i2 += 2 
                                          continue 
                              raise CmpErrorCode(name, tokens1[i1].offset, tokens1[i1], tokens2[i2], tokens1, tokens2) 
                        elif ((tokens1[i1].type in JUMP_OPs) and (tokens1[i1].pattr != tokens2[i2].pattr)): 
                              dest1 = int(tokens1[i1].pattr) 
                              dest2 = int(tokens2[i2].pattr) 
                              if (tokens1[i1].type == 'JUMP_BACK'): 
                                    if (offset_map[dest1] != dest2): 
                                          raise CmpErrorCode(name, tokens1[i1].offset, tokens1[i1], tokens2[i2], tokens1, tokens2) 
                              elif (dest1 in check_jumps): 
                                    check_jumps[dest1].append((i1, i2, dest2)) 
                              else: 
                                    check_jumps[dest1] = [(i1, i2, dest2)] 
                        i1 += 1 
                        i2 += 1 
                  del tokens1, tokens2 
            elif (member == 'co_consts'): 
                  codes1 = (c for c in code_obj1.co_consts if (type(c) == types.CodeType)) 
                  codes2 = (c for c in code_obj2.co_consts if (type(c) == types.CodeType)) 
                  for (c1, c2) in zip(codes1, codes2): 
                        cmp_code_objects(version, c1, c2, name=name) 
            elif (getattr(code_obj1, member) != getattr(code_obj2, member)): 
                  raise CmpErrorMember(name, member, getattr(code_obj1, member), getattr(code_obj2, member))",'Compare two code-objects.   This is the main part of this module.'
"def compare_code_with_srcfile(pyc_filename, src_filename):
     (version, code_obj1) = uncompyle2._load_module(pyc_filename) 
      code_obj2 = uncompyle2._load_file(src_filename) 
      cmp_code_objects(version, code_obj1, code_obj2)",'Compare a .pyc with a source code file.'
"def compare_files(pyc_filename1, pyc_filename2):
     (version, code_obj1) = uncompyle2._load_module(pyc_filename1) 
      (version, code_obj2) = uncompyle2._load_module(pyc_filename2) 
      cmp_code_objects(version, code_obj1, code_obj2)",'Compare two .pyc files.'
"def find_globals(node, globs):
     for n in node: 
            if isinstance(n, AST): 
                  globs = find_globals(n, globs) 
            elif (n.type in ('STORE_GLOBAL', 'DELETE_GLOBAL')): 
                  globs.add(n.pattr) 
      return globs",'Find globals in this statement.'
"def find_all_globals(node, globs):
     for n in node: 
            if isinstance(n, AST): 
                  globs = find_all_globals(n, globs) 
            elif (n.type in ('STORE_GLOBAL', 'DELETE_GLOBAL', 'LOAD_GLOBAL')): 
                  globs.add(n.pattr) 
      return globs",'Find globals in this statement.'
"def sendEmail(SUBJECT, BODY, TO, FROM, SENDER, PASSWORD, SMTP_SERVER):
     for body_charset in ('US-ASCII', 'ISO-8859-1', 'UTF-8'): 
            try: 
                  BODY.encode(body_charset) 
            except UnicodeError: 
                  pass 
            else: 
                  break 
      msg = MIMEText(BODY.encode(body_charset), 'html', body_charset) 
      msg['From'] = SENDER 
      msg['To'] = TO 
      msg['Subject'] = SUBJECT 
      SMTP_PORT = 587 
      session = smtplib.SMTP(SMTP_SERVER, SMTP_PORT) 
      session.starttls() 
      session.login(FROM, PASSWORD) 
      session.sendmail(SENDER, TO, msg.as_string()) 
      session.quit()",'Sends an HTML email.'
"def emailUser(profile, SUBJECT='', BODY=''):
     def generateSMSEmail(profile): 
            ""\n                                                Generates      an      email      from      a      user's      phone      number      based      on      their      carrier.\n                                                "" 
            if ((profile['carrier'] is None) or (not profile['phone_number'])): 
                  return None 
            return ((str(profile['phone_number']) + '@') + profile['carrier']) 
      if (profile['prefers_email'] and profile['gmail_address']): 
            if BODY: 
                  BODY = ((profile['first_name'] + ',<br><br>Here      are      your      top      headlines:') + BODY) 
                  BODY += '<br>Sent      from      your      Jasper' 
            recipient = profile['gmail_address'] 
            if (profile['first_name'] and profile['last_name']): 
                  recipient = (((profile['first_name'] + '      ') + profile['last_name']) + ('      <%s>' % recipient)) 
      else: 
            recipient = generateSMSEmail(profile) 
      if (not recipient): 
            return False 
      try: 
            if ('mailgun' in profile): 
                  user = profile['mailgun']['username'] 
                  password = profile['mailgun']['password'] 
                  server = 'smtp.mailgun.org' 
            else: 
                  user = profile['gmail_address'] 
                  password = profile['gmail_password'] 
                  server = 'smtp.gmail.com' 
            sendEmail(SUBJECT, BODY, recipient, user, 'Jasper      <jasper>', password, server) 
            return True 
      except: 
            return False","'sends an email.   Arguments:   profile -- contains information related to the user (e.g., email   address)   SUBJECT -- subject line of the email   BODY -- body text of the email'"
"def getTimezone(profile):
     try: 
            return timezone(profile['timezone']) 
      except: 
            return None","'Returns the pytz timezone for a given profile.   Arguments:   profile -- contains information related to the user (e.g., email   address)'"
"def generateTinyURL(URL):
     target = ('http://tinyurl.com/api-create.php?url=' + URL) 
      response = urllib2.urlopen(target) 
      return response.read()",'Generates a compressed URL.   Arguments:   URL -- the original URL to-be compressed'
"def isNegative(phrase):
     return bool(re.search(""\\b(no(t)?|don\\'t|stop|end)\\b"", phrase, re.IGNORECASE))",'Returns True if the input phrase has a negative sentiment.   Arguments:   phrase -- the input phrase to-be evaluated'
"def isPositive(phrase):
     return bool(re.search('\\b(sure|yes|yeah|go)\\b', phrase, re.IGNORECASE))",'Returns True if the input phrase has a positive sentiment.   Arguments:   phrase -- the input phrase to-be evaluated'
"def clean(input):
     return detectYears(input)","'Manually adjust output text before it\'s translated into   actual speech by the TTS system. This is to fix minior   idiomatic issues, for example, that 1901 is pronounced   ""one thousand, ninehundred and one"" rather than   ""nineteen oh one"".   Arguments:   input -- original speech text to-be modified'"
"def get_engine_by_slug(slug=None):
     if ((not slug) or (type(slug) is not str)): 
            raise TypeError(""Invalid      slug      '%s'"", slug) 
      selected_engines = filter((lambda engine: (hasattr(engine, 'SLUG') and (engine.SLUG == slug))), get_engines()) 
      if (len(selected_engines) == 0): 
            raise ValueError((""No      TTS      engine      found      for      slug      '%s'"" % slug)) 
      else: 
            if (len(selected_engines) > 1): 
                  print (""WARNING:      Multiple      TTS      engines      found      for      slug      '%s'.      "" + ('This      is      most      certainly      a      bug.' % slug)) 
            engine = selected_engines[0] 
            if (not engine.is_available()): 
                  raise ValueError(((""TTS      engine      '%s'      is      not      available      (due      to      "" + 'missing      dependencies,      etc.)') % slug)) 
            return engine",'Returns:   A speaker implementation available on the current platform   Raises:   ValueError if no speaker implementation is supported on this platform'
"def get_phrases_from_module(module):
     return (module.WORDS if hasattr(module, 'WORDS') else [])",'Gets phrases from a module.   Arguments:   module -- a module reference   Returns:   The list of phrases in this module.'
"def get_keyword_phrases():
     phrases = [] 
      with open(jasperpath.data('keyword_phrases'), mode='r') as f: 
            for line in f: 
                  phrase = line.strip() 
                  if phrase: 
                        phrases.append(phrase) 
      return phrases",'Gets the keyword phrases from the keywords file in the jasper data dir.   Returns:   A list of keyword phrases.'
"def get_all_phrases():
     phrases = [] 
      modules = brain.Brain.get_modules() 
      for module in modules: 
            phrases.extend(get_phrases_from_module(module)) 
      return sorted(list(set(phrases)))",'Gets phrases from all modules.   Returns:   A list of phrases in all modules plus additional phrases passed to this   function.'
"def handle(text, mic, profile):
     oauth_access_token = profile['keys']['FB_TOKEN'] 
      graph = facebook.GraphAPI(oauth_access_token) 
      try: 
            results = graph.request('me/notifications') 
      except facebook.GraphAPIError: 
            mic.say((('I      have      not      been      authorized      to      query      your      Facebook.      If      you      ' + 'would      like      to      check      your      notifications      in      the      future,      ') + 'please      visit      the      Jasper      dashboard.')) 
            return 
      except: 
            mic.say(""I      apologize,      there's      a      problem      with      that      service      at      the      moment."") 
      if (not len(results['data'])): 
            mic.say('You      have      no      Facebook      notifications.      ') 
            return 
      updates = [] 
      for notification in results['data']: 
            updates.append(notification['title']) 
      count = len(results['data']) 
      mic.say((((('You      have      ' + str(count)) + '      Facebook      notifications.      ') + '      '.join(updates)) + '.      ')) 
      return","'Responds to user-input, typically speech text, with a summary of   the user\'s Facebook notifications, including a count and details   related to each individual notification.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('\\bnotification|Facebook\\b', text, re.IGNORECASE))","'Returns True if the input is related to Facebook notifications.   Arguments:   text -- user-input, typically transcribed speech'"
"def getSender(email):
     sender = email['From'] 
      m = re.match('(.*)\\s<.*>', sender) 
      if m: 
            return m.group(1) 
      return sender",'Returns the best-guess sender of an email.   Arguments:   email -- the email whose sender is desired   Returns:   Sender of the email.'
"def getMostRecentDate(emails):
     dates = [getDate(e) for e in emails] 
      dates.sort(reverse=True) 
      if dates: 
            return dates[0] 
      return None",'Returns the most recent date of any email in the list provided.   Arguments:   emails -- a list of emails to check   Returns:   Date of the most recent email.'
"def fetchUnreadEmails(profile, since=None, markRead=False, limit=None):
     conn = imaplib.IMAP4_SSL('imap.gmail.com') 
      conn.debug = 0 
      conn.login(profile['gmail_address'], profile['gmail_password']) 
      conn.select(readonly=(not markRead)) 
      msgs = [] 
      (retcode, messages) = conn.search(None, '(UNSEEN)') 
      if ((retcode == 'OK') and (messages != [''])): 
            numUnread = len(messages[0].split('      ')) 
            if (limit and (numUnread > limit)): 
                  return numUnread 
            for num in messages[0].split('      '): 
                  (ret, data) = conn.fetch(num, '(RFC822)') 
                  msg = email.message_from_string(data[0][1]) 
                  if ((not since) or (getDate(msg) > since)): 
                        msgs.append(msg) 
      conn.close() 
      conn.logout() 
      return msgs","'Fetches a list of unread email objects from a user\'s Gmail inbox.   Arguments:   profile -- contains information related to the user (e.g., Gmail   address)   since -- if provided, no emails before this date will be returned   markRead -- if True, marks all returned emails as read in target inbox   Returns:   A list of unread email objects.'"
"def handle(text, mic, profile):
     try: 
            msgs = fetchUnreadEmails(profile, limit=5) 
            if isinstance(msgs, int): 
                  response = ('You      have      %d      unread      emails.' % msgs) 
                  mic.say(response) 
                  return 
            senders = [getSender(e) for e in msgs] 
      except imaplib.IMAP4.error: 
            mic.say(""I'm      sorry.      I'm      not      authenticated      to      work      with      your      Gmail."") 
            return 
      if (not senders): 
            mic.say('You      have      no      unread      emails.') 
      elif (len(senders) == 1): 
            mic.say((('You      have      one      unread      email      from      ' + senders[0]) + '.')) 
      else: 
            response = ('You      have      %d      unread      emails' % len(senders)) 
            unique_senders = list(set(senders)) 
            if (len(unique_senders) > 1): 
                  unique_senders[(-1)] = ('and      ' + unique_senders[(-1)]) 
                  response += '.      Senders      include:      ' 
                  response += '...'.join(senders) 
            else: 
                  response += ('      from      ' + unique_senders[0]) 
            mic.say(response)","'Responds to user-input, typically speech text, with a summary of   the user\'s Gmail inbox, reporting on the number of unread emails   in the inbox, as well as their senders.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., Gmail   address)'"
"def isValid(text):
     return bool(re.search('\\bemail\\b', text, re.IGNORECASE))","'Returns True if the input is related to email.   Arguments:   text -- user-input, typically transcribed speech'"
"def handle(text, mic, profile):
     logger = logging.getLogger(__name__) 
      kwargs = {} 
      if ('mpdclient' in profile): 
            if ('server' in profile['mpdclient']): 
                  kwargs['server'] = profile['mpdclient']['server'] 
            if ('port' in profile['mpdclient']): 
                  kwargs['port'] = int(profile['mpdclient']['port']) 
      logger.debug('Preparing      to      start      music      module') 
      try: 
            mpdwrapper = MPDWrapper(**kwargs) 
      except: 
            logger.error(""Couldn't      connect      to      MPD      server"", exc_info=True) 
            mic.say((""I'm      sorry.      It      seems      that      Spotify      is      not      enabled.      Please      "" + 'read      the      documentation      to      learn      how      to      configure      Spotify.')) 
            return 
      mic.say(""Please      give      me      a      moment,      I'm      loading      your      Spotify      playlists."") 
      persona = 'JASPER' 
      logger.debug('Starting      music      mode') 
      music_mode = MusicMode(persona, mic, mpdwrapper) 
      music_mode.handleForever() 
      logger.debug('Exiting      music      mode') 
      return","'Responds to user-input, typically speech text, by telling a joke.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return any(((word in text.upper()) for word in WORDS))","'Returns True if the input is related to jokes/humor.   Arguments:   text -- user-input, typically transcribed speech'"
"def reconnect(func, *default_args, **default_kwargs):
     def wrap(self, *default_args, **default_kwargs): 
            try: 
                  self.client.connect(self.server, self.port) 
            except: 
                  pass 
            try: 
                  return func(self, *default_args, **default_kwargs) 
            except: 
                  self.client = mpd.MPDClient() 
                  self.client.timeout = None 
                  self.client.idletimeout = None 
                  self.client.connect(self.server, self.port) 
                  return func(self, *default_args, **default_kwargs) 
      return wrap",'Reconnects before running'
"def handle(text, mic, profile):
     messages = [""I'm      sorry,      could      you      repeat      that?"", 'My      apologies,      could      you      try      saying      that      again?', 'Say      that      again?', 'I      beg      your      pardon?'] 
      message = random.choice(messages) 
      mic.say(message)","'Reports that the user has unclear or unusable input.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def replaceAcronyms(text):
     def parseDirections(text): 
            words = {'N': 'north', 'S': 'south', 'E': 'east', 'W': 'west'} 
            output = [words[w] for w in list(text)] 
            return '      '.join(output) 
      acronyms = re.findall('\\b([NESW]+)\\b', text) 
      for w in acronyms: 
            text = text.replace(w, parseDirections(w)) 
      text = re.sub('(\\b\\d+)F(\\b)', '\\g<1>      Fahrenheit\\g<2>', text) 
      text = re.sub('(\\b)mph(\\b)', '\\g<1>miles      per      hour\\g<2>', text) 
      text = re.sub('(\\b)in\\.', '\\g<1>inches', text) 
      return text",'Replaces some commonly-used acronyms for an improved verbal weather report.'
"def handle(text, mic, profile):
     forecast = None 
      if ('wmo_id' in profile): 
            forecast = get_forecast_by_wmo_id(str(profile['wmo_id'])) 
      elif ('location' in profile): 
            forecast = get_forecast_by_name(str(profile['location'])) 
      if (not forecast): 
            mic.say((""I'm      sorry,      I      can't      seem      to      access      that      information.      Please      "" + ""make      sure      that      you've      set      your      location      on      the      dashboard."")) 
            return 
      tz = getTimezone(profile) 
      service = DateService(tz=tz) 
      date = service.extractDay(text) 
      if (not date): 
            date = datetime.datetime.now(tz=tz) 
      weekday = service.__daysOfWeek__[date.weekday()] 
      if (date.weekday() == datetime.datetime.now(tz=tz).weekday()): 
            date_keyword = 'Today' 
      elif (date.weekday() == ((datetime.datetime.now(tz=tz).weekday() + 1) % 7)): 
            date_keyword = 'Tomorrow' 
      else: 
            date_keyword = ('On      ' + weekday) 
      output = None 
      for entry in forecast: 
            try: 
                  date_desc = entry['title'].split()[0].strip().lower() 
                  if (date_desc == 'forecast'): 
                        date_desc = entry['title'].split()[2].strip().lower() 
                        weather_desc = entry['summary'] 
                  elif (date_desc == 'current'): 
                        continue 
                  else: 
                        weather_desc = entry['summary'].split('-')[1] 
                  if (weekday == date_desc): 
                        output = (((date_keyword + ',      the      weather      will      be      ') + weather_desc) + '.') 
                        break 
            except: 
                  continue 
      if output: 
            output = replaceAcronyms(output) 
            mic.say(output) 
      else: 
            mic.say(""I'm      sorry.      I      can't      see      that      far      ahead."")","'Responds to user-input, typically speech text, with a summary of   the relevant weather for the requested date (typically, weather   information will not be available for days beyond tomorrow).   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search(('\\b(weathers?|temperature|forecast|outside|hot|' + 'cold|jacket|coat|rain)\\b'), text, re.IGNORECASE))","'Returns True if the text is related to the weather.   Arguments:   text -- user-input, typically transcribed speech'"
"def handle(text, mic, profile):
     joke = getRandomJoke() 
      mic.say('Knock      knock') 
      def firstLine(text): 
            mic.say(joke[0]) 
            def punchLine(text): 
                  mic.say(joke[1]) 
            punchLine(mic.activeListen()) 
      firstLine(mic.activeListen())","'Responds to user-input, typically speech text, by telling a joke.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('\\bjoke\\b', text, re.IGNORECASE))","'Returns True if the input is related to jokes/humor.   Arguments:   text -- user-input, typically transcribed speech'"
"def handle(text, mic, profile):
     tz = getTimezone(profile) 
      now = datetime.datetime.now(tz=tz) 
      service = DateService() 
      response = service.convertTime(now) 
      mic.say(('It      is      %s      right      now.' % response))","'Reports the current time based on the user\'s timezone.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('\\btime\\b', text, re.IGNORECASE))","'Returns True if input is related to the time.   Arguments:   text -- user-input, typically transcribed speech'"
"def handle(text, mic, profile):
     mic.say('Pulling      up      the      news') 
      articles = getTopArticles(maxResults=3) 
      titles = ['      '.join(x.title.split('      -      ')[:(-1)]) for x in articles] 
      all_titles = '...      '.join((((str((idx + 1)) + ')') + title) for (idx, title) in enumerate(titles))) 
      def handleResponse(text): 
            def extractOrdinals(text): 
                  output = [] 
                  service = NumberService() 
                  for w in text.split(): 
                        if (w in service.__ordinals__): 
                              output.append(service.__ordinals__[w]) 
                  return [service.parse(w) for w in output] 
            chosen_articles = extractOrdinals(text) 
            send_all = ((not chosen_articles) and app_utils.isPositive(text)) 
            if (send_all or chosen_articles): 
                  mic.say('Sure,      just      give      me      a      moment') 
                  if profile['prefers_email']: 
                        body = '<ul>' 
                  def formatArticle(article): 
                        tiny_url = app_utils.generateTinyURL(article.URL) 
                        if profile['prefers_email']: 
                              return (""<li><a      href='%s'>%s</a></li>"" % (tiny_url, article.title)) 
                        else: 
                              return ((article.title + '      --      ') + tiny_url) 
                  for (idx, article) in enumerate(articles): 
                        if (send_all or ((idx + 1) in chosen_articles)): 
                              article_link = formatArticle(article) 
                              if profile['prefers_email']: 
                                    body += article_link 
                              elif (not app_utils.emailUser(profile, SUBJECT='', BODY=article_link)): 
                                    mic.say((((""I'm      having      trouble      sending      you      these      "" + 'articles.      Please      make      sure      that      your      ') + 'phone      number      and      carrier      are      correct      ') + 'on      the      dashboard.')) 
                                    return 
                  if profile['prefers_email']: 
                        body += '</ul>' 
                        if (not app_utils.emailUser(profile, SUBJECT='Your      Top      Headlines', BODY=body)): 
                              mic.say(((""I'm      having      trouble      sending      you      these      articles.      "" + 'Please      make      sure      that      your      phone      number      and      ') + 'carrier      are      correct      on      the      dashboard.')) 
                              return 
                  mic.say('All      set') 
            else: 
                  mic.say('OK      I      will      not      send      any      articles') 
      if ('phone_number' in profile): 
            mic.say(((('Here      are      the      current      top      headlines.      ' + all_titles) + '.      Would      you      like      me      to      send      you      these      articles?      ') + 'If      so,      which?')) 
            handleResponse(mic.activeListen()) 
      else: 
            mic.say(('Here      are      the      current      top      headlines.      ' + all_titles))","'Responds to user-input, typically speech text, with a summary of   the day\'s top news headlines, sending them to the user over email   if desired.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('\\b(news|headline)\\b', text, re.IGNORECASE))","'Returns True if the input is related to the news.   Arguments:   text -- user-input, typically transcribed speech'"
"def handle(text, mic, profile):
     messages = [""It's      42,      you      idiot."", ""It's      42.      How      many      times      do      I      have      to      tell      you?""] 
      message = random.choice(messages) 
      mic.say(message)","'Responds to user-input, typically speech text, by relaying the   meaning of life.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('\\bmeaning      of      life\\b', text, re.IGNORECASE))","'Returns True if the input is related to the meaning of life.   Arguments:   text -- user-input, typically transcribed speech'"
"def handle(text, mic, profile):
     oauth_access_token = profile['keys']['FB_TOKEN'] 
      graph = facebook.GraphAPI(oauth_access_token) 
      try: 
            results = graph.request('me/friends', args={'fields': 'id,name,birthday'}) 
      except facebook.GraphAPIError: 
            mic.say((('I      have      not      been      authorized      to      query      your      Facebook.      If      you      ' + 'would      like      to      check      birthdays      in      the      future,      please      visit      ') + 'the      Jasper      dashboard.')) 
            return 
      except: 
            mic.say(""I      apologize,      there's      a      problem      with      that      service      at      the      moment."") 
            return 
      needle = datetime.datetime.now(tz=getTimezone(profile)).strftime('%m/%d') 
      people = [] 
      for person in results['data']: 
            try: 
                  if (needle in person['birthday']): 
                        people.append(person['name']) 
            except: 
                  continue 
      if (len(people) > 0): 
            if (len(people) == 1): 
                  output = (people[0] + '      has      a      birthday      today.') 
            else: 
                  output = (((('Your      friends      with      birthdays      today      are      ' + ',      '.join(people[:(-1)])) + '      and      ') + people[(-1)]) + '.') 
      else: 
            output = 'None      of      your      friends      have      birthdays      today.' 
      mic.say(output)","'Responds to user-input, typically speech text, by listing the user\'s   Facebook friends with birthdays today.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('birthday', text, re.IGNORECASE))","'Returns True if the input is related to birthdays.   Arguments:   text -- user-input, typically transcribed speech'"
"def getTopStories(maxResults=None):
     hdr = {'User-Agent': 'Mozilla/5.0'} 
      req = urllib2.Request(URL, headers=hdr) 
      page = urllib2.urlopen(req).read() 
      soup = BeautifulSoup(page) 
      matches = soup.findAll('td', class_='title') 
      matches = [m.a for m in matches if (m.a and (m.text != u'More'))] 
      matches = [HNStory(m.text, m['href']) for m in matches] 
      if maxResults: 
            num_stories = min(maxResults, len(matches)) 
            return random.sample(matches, num_stories) 
      return matches","'Returns the top headlines from Hacker News.   Arguments:   maxResults -- if provided, returns a random sample of size maxResults'"
"def handle(text, mic, profile):
     mic.say('Pulling      up      some      stories.') 
      stories = getTopStories(maxResults=3) 
      all_titles = '...      '.join((((str((idx + 1)) + ')      ') + story.title) for (idx, story) in enumerate(stories))) 
      def handleResponse(text): 
            def extractOrdinals(text): 
                  output = [] 
                  service = NumberService() 
                  for w in text.split(): 
                        if (w in service.__ordinals__): 
                              output.append(service.__ordinals__[w]) 
                  return [service.parse(w) for w in output] 
            chosen_articles = extractOrdinals(text) 
            send_all = ((not chosen_articles) and app_utils.isPositive(text)) 
            if (send_all or chosen_articles): 
                  mic.say('Sure,      just      give      me      a      moment') 
                  if profile['prefers_email']: 
                        body = '<ul>' 
                  def formatArticle(article): 
                        tiny_url = app_utils.generateTinyURL(article.URL) 
                        if profile['prefers_email']: 
                              return (""<li><a      href='%s'>%s</a></li>"" % (tiny_url, article.title)) 
                        else: 
                              return ((article.title + '      --      ') + tiny_url) 
                  for (idx, article) in enumerate(stories): 
                        if (send_all or ((idx + 1) in chosen_articles)): 
                              article_link = formatArticle(article) 
                              if profile['prefers_email']: 
                                    body += article_link 
                              elif (not app_utils.emailUser(profile, SUBJECT='', BODY=article_link)): 
                                    mic.say((((""I'm      having      trouble      sending      you      these      "" + 'articles.      Please      make      sure      that      your      ') + 'phone      number      and      carrier      are      correct      ') + 'on      the      dashboard.')) 
                                    return 
                  if profile['prefers_email']: 
                        body += '</ul>' 
                        if (not app_utils.emailUser(profile, SUBJECT=('From      the      Front      Page      of      ' + 'Hacker      News'), BODY=body)): 
                              mic.say(((""I'm      having      trouble      sending      you      these      articles.      "" + 'Please      make      sure      that      your      phone      number      and      ') + 'carrier      are      correct      on      the      dashboard.')) 
                              return 
                  mic.say('All      done.') 
            else: 
                  mic.say('OK      I      will      not      send      any      articles') 
      if ((not profile['prefers_email']) and profile['phone_number']): 
            mic.say(((('Here      are      some      front-page      articles.      ' + all_titles) + '.      Would      you      like      me      to      send      you      these?      ') + 'If      so,      which?')) 
            handleResponse(mic.activeListen()) 
      else: 
            mic.say(('Here      are      some      front-page      articles.      ' + all_titles))","'Responds to user-input, typically speech text, with a sample of   Hacker News\'s top headlines, sending them to the user over email   if desired.   Arguments:   text -- user-input, typically transcribed speech   mic -- used to interact with the user (for both input and output)   profile -- contains information related to the user (e.g., phone   number)'"
"def isValid(text):
     return bool(re.search('\\b(hack(er)?|HN)\\b', text, re.IGNORECASE))","'Returns True if the input is related to Hacker News.   Arguments:   text -- user-input, typically transcribed speech'"
"def get_engine_by_slug(slug=None):
     if ((not slug) or (type(slug) is not str)): 
            raise TypeError(""Invalid      slug      '%s'"", slug) 
      selected_engines = filter((lambda engine: (hasattr(engine, 'SLUG') and (engine.SLUG == slug))), get_engines()) 
      if (len(selected_engines) == 0): 
            raise ValueError((""No      STT      engine      found      for      slug      '%s'"" % slug)) 
      else: 
            if (len(selected_engines) > 1): 
                  print ((""WARNING:      Multiple      STT      engines      found      for      slug      '%s'.      "" + 'This      is      most      certainly      a      bug.') % slug) 
            engine = selected_engines[0] 
            if (not engine.is_available()): 
                  raise ValueError((((""STT      engine      '%s'      is      not      available      (due      to      "" + 'missing      dependencies,      missing      ') + 'dependencies,      etc.)') % slug)) 
            return engine",'Returns:   An STT Engine implementation available on the current platform   Raises:   ValueError if no speaker implementation is supported on this platform'
"def check_network_connection(server='www.google.com'):
     logger = logging.getLogger(__name__) 
      logger.debug(""Checking      network      connection      to      server      '%s'..."", server) 
      try: 
            host = socket.gethostbyname(server) 
            socket.create_connection((host, 80), 2) 
      except Exception: 
            logger.debug('Network      connection      not      working') 
            return False 
      else: 
            logger.debug('Network      connection      working') 
            return True","'Checks if jasper can connect a network server.   Arguments:   server -- (optional) the server to connect with (Default:   ""www.google.com"")   Returns:   True or False'"
"def check_executable(executable):
     logger = logging.getLogger(__name__) 
      logger.debug(""Checking      executable      '%s'..."", executable) 
      executable_path = find_executable(executable) 
      found = (executable_path is not None) 
      if found: 
            logger.debug(""Executable      '%s'      found:      '%s'"", executable, executable_path) 
      else: 
            logger.debug(""Executable      '%s'      not      found"", executable) 
      return found","'Checks if an executable exists in $PATH.   Arguments:   executable -- the name of the executable (e.g. ""echo"")   Returns:   True or False'"
"def check_python_import(package_or_module):
     logger = logging.getLogger(__name__) 
      logger.debug(""Checking      python      import      '%s'..."", package_or_module) 
      loader = pkgutil.get_loader(package_or_module) 
      found = (loader is not None) 
      if found: 
            logger.debug(""Python      %s      '%s'      found:      %r"", ('package' if loader.is_package(package_or_module) else 'module'), package_or_module, loader.get_filename()) 
      else: 
            logger.debug(""Python      import      '%s'      not      found"", package_or_module) 
      return found",'Checks if a python package or module is importable.   Arguments:   package_or_module -- the package or module name to check   Returns:   True or False'
"def get_pip_requirements(fname=os.path.join(jasperpath.LIB_PATH, 'requirements.txt')):
     logger = logging.getLogger(__name__) 
      if os.access(fname, os.R_OK): 
            reqs = list(pip.req.parse_requirements(fname)) 
            logger.debug(""Found      %d      PIP      requirements      in      file      '%s'"", len(reqs), fname) 
            return reqs 
      else: 
            logger.debug(""PIP      requirements      file      '%s'      not      found      or      not      readable"", fname)","'Gets the PIP requirements from a text file. If the files does not exists   or is not readable, it returns None   Arguments:   fname -- (optional) the requirement text file (Default:   ""client/requirements.txt"")   Returns:   A list of pip requirement objects or None'"
"def get_git_revision():
     logger = logging.getLogger(__name__) 
      if (not check_executable('git')): 
            logger.warning(""'git'      command      not      found,      git      revision      not      detectable"") 
            return None 
      output = subprocess.check_output(['git', 'rev-parse', 'HEAD']).strip() 
      if (not output): 
            logger.warning(""Couldn't      detect      git      revision      (not      a      git      repository?)"") 
            return None 
      return output","'Gets the current git revision hash as hex string. If the git executable is   missing or git is unable to get the revision, None is returned   Returns:   A hex string or None'"
"def run():
     logger = logging.getLogger(__name__) 
      loglvl = logger.getEffectiveLevel() 
      if ((loglvl == logging.NOTSET) or (loglvl > logging.INFO)): 
            logger.setLevel(logging.INFO) 
      logger.info(('Starting      jasper      diagnostic      at      %s' % time.strftime('%c'))) 
      logger.info('Git      revision:      %r', get_git_revision()) 
      failed_checks = 0 
      if (not check_network_connection()): 
            failed_checks += 1 
      for executable in ['phonetisaurus-g2p', 'espeak', 'say']: 
            if (not check_executable(executable)): 
                  logger.warning(""Executable      '%s'      is      missing      in      $PATH"", executable) 
                  failed_checks += 1 
      for req in get_pip_requirements(): 
            logger.debug(""Checking      PIP      package      '%s'..."", req.name) 
            if (not req.check_if_exists()): 
                  logger.warning(""PIP      package      '%s'      is      missing"", req.name) 
                  failed_checks += 1 
            else: 
                  logger.debug(""PIP      package      '%s'      found"", req.name) 
      for fname in [os.path.join(jasperpath.APP_PATH, os.pardir, 'phonetisaurus', 'g014b2b.fst')]: 
            logger.debug(""Checking      file      '%s'..."", fname) 
            if (not os.access(fname, os.R_OK)): 
                  logger.warning(""File      '%s'      is      missing"", fname) 
                  failed_checks += 1 
            else: 
                  logger.debug(""File      '%s'      found"", fname) 
      if (not failed_checks): 
            logger.info('All      checks      passed') 
      else: 
            logger.info(('%d      checks      failed' % failed_checks)) 
      return failed_checks",'Performs a series of checks against the system and writes the results to   the logging system.   Returns:   The number of failed checks as integer'
"def sanitize_module_name(module_name):
     module_name = module_name.replace('-', '_').replace('.', '_') 
      if (module_name[0] not in string.ascii_letters): 
            module_name = ('a' + module_name) 
      return module_name","'Sanitize the given module name, by replacing dashes and points   with underscores and prefixing it with a letter if it doesn\'t start   with one'"
"def tunnel_request_data(host, port, proxy_auth_header=None):
     host_value = ((to_bytes(host, encoding='ascii') + ':') + to_bytes(str(port))) 
      tunnel_req = (('CONNECT      ' + host_value) + '      HTTP/1.1\r\n') 
      tunnel_req += (('Host:      ' + host_value) + '\r\n') 
      if proxy_auth_header: 
            tunnel_req += (('Proxy-Authorization:      ' + proxy_auth_header) + '\r\n') 
      tunnel_req += '\r\n' 
      return tunnel_req","'Return binary content of a CONNECT request.   >>> from scrapy.utils.python import to_native_str as s   >>> s(tunnel_request_data(""example.com"", 8080))   \'CONNECT example.com:8080 HTTP/1.1\r\nHost: example.com:8080\r\n\r\n\'   >>> s(tunnel_request_data(""example.com"", 8080, b""123""))   \'CONNECT example.com:8080 HTTP/1.1\r\nHost: example.com:8080\r\nProxy-Authorization: 123\r\n\r\n\'   >>> s(tunnel_request_data(b""example.com"", ""8090""))   \'CONNECT example.com:8090 HTTP/1.1\r\nHost: example.com:8090\r\n\r\n\''"
"def _parse(url):
     url = url.strip() 
      parsed = urlparse(url) 
      return _parsed_url_args(parsed)","'Return tuple of (scheme, netloc, host, port, path),   all in bytes except for port which is int.   Assume url is from Request.url, which was passed via safe_url_string   and is ascii-only.'"
"def _get_spider_loader(settings):
     if settings.get('SPIDER_MANAGER_CLASS'): 
            warnings.warn('SPIDER_MANAGER_CLASS      option      is      deprecated.      Please      use      SPIDER_LOADER_CLASS.', category=ScrapyDeprecationWarning, stacklevel=2) 
      cls_path = settings.get('SPIDER_MANAGER_CLASS', settings.get('SPIDER_LOADER_CLASS')) 
      loader_cls = load_object(cls_path) 
      try: 
            verifyClass(ISpiderLoader, loader_cls) 
      except DoesNotImplement: 
            warnings.warn('SPIDER_LOADER_CLASS      (previously      named      SPIDER_MANAGER_CLASS)      does      not      fully      implement      scrapy.interfaces.ISpiderLoader      interface.      Please      add      all      missing      methods      to      avoid      unexpected      runtime      errors.', category=ScrapyDeprecationWarning, stacklevel=2) 
      return loader_cls.from_settings(settings.frozencopy())",'Get SpiderLoader instance from settings'
"def inspect_response(response, spider):
     Shell(spider.crawler).start(response=response, spider=spider)",'Open a shell to inspect the given response'
"def _request_deferred(request):
     request_callback = request.callback 
      request_errback = request.errback 
      def _restore_callbacks(result): 
            request.callback = request_callback 
            request.errback = request_errback 
            return result 
      d = defer.Deferred() 
      d.addBoth(_restore_callbacks) 
      if request.callback: 
            d.addCallbacks(request.callback, request.errback) 
      (request.callback, request.errback) = (d.callback, d.errback) 
      return d","'Wrap a request inside a Deferred.   This function is harmful, do not use it until you know what you are doing.   This returns a Deferred whose first pair of callbacks are the request   callback and errback. The Deferred also triggers when the request   callback/errback is executed (ie. when the request is downloaded)   WARNING: Do not call request.replace() until after the deferred is called.'"
"def get_settings_priority(priority):
     if isinstance(priority, six.string_types): 
            return SETTINGS_PRIORITIES[priority] 
      else: 
            return priority","'Small helper function that looks up a given string priority in the   :attr:`~scrapy.settings.SETTINGS_PRIORITIES` dictionary and returns its   numerical value, or directly returns a given numerical priority.'"
"def iter_default_settings():
     for name in dir(default_settings): 
            if name.isupper(): 
                  (yield (name, getattr(default_settings, name)))","'Return the default settings as an iterator of (name, value) tuples'"
"def overridden_settings(settings):
     for (name, defvalue) in iter_default_settings(): 
            value = settings[name] 
            if ((not isinstance(defvalue, dict)) and (value != defvalue)): 
                  (yield (name, value))",'Return a dict of the settings that have been overridden'
"def potential_domain_matches(domain):
     matches = [domain] 
      try: 
            start = (domain.index('.') + 1) 
            end = domain.rindex('.') 
            while (start < end): 
                  matches.append(domain[start:]) 
                  start = (domain.index('.', start) + 1) 
      except ValueError: 
            pass 
      return (matches + [('.' + d) for d in matches])","'Potential domain matches for a cookie   >>> potential_domain_matches(\'www.example.com\')   [\'www.example.com\', \'example.com\', \'.www.example.com\', \'.example.com\']'"
"def _get_form(response, formname, formid, formnumber, formxpath):
     root = create_root_node(response.text, lxml.html.HTMLParser, base_url=get_base_url(response)) 
      forms = root.xpath('//form') 
      if (not forms): 
            raise ValueError(('No      <form>      element      found      in      %s' % response)) 
      if (formname is not None): 
            f = root.xpath(('//form[@name=""%s""]' % formname)) 
            if f: 
                  return f[0] 
      if (formid is not None): 
            f = root.xpath(('//form[@id=""%s""]' % formid)) 
            if f: 
                  return f[0] 
      if (formxpath is not None): 
            nodes = root.xpath(formxpath) 
            if nodes: 
                  el = nodes[0] 
                  while True: 
                        if (el.tag == 'form'): 
                              return el 
                        el = el.getparent() 
                        if (el is None): 
                              break 
            encoded = (formxpath if six.PY3 else formxpath.encode('unicode_escape')) 
            raise ValueError(('No      <form>      element      found      with      %s' % encoded)) 
      if (formnumber is not None): 
            try: 
                  form = forms[formnumber] 
            except IndexError: 
                  raise IndexError(('Form      number      %d      not      found      in      %s' % (formnumber, response))) 
            else: 
                  return form",'Find the form element'
"def _get_clickable(clickdata, form):
     clickables = [el for el in form.xpath('descendant::*[(self::input      or      self::button)      and      re:test(@type,      ""^submit$"",      ""i"")]|descendant::button[not(@type)]', namespaces={'re': 'http://exslt.org/regular-expressions'})] 
      if (not clickables): 
            return 
      if (clickdata is None): 
            el = clickables[0] 
            return (el.get('name'), (el.get('value') or '')) 
      nr = clickdata.get('nr', None) 
      if (nr is not None): 
            try: 
                  el = list(form.inputs)[nr] 
            except IndexError: 
                  pass 
            else: 
                  return (el.get('name'), (el.get('value') or '')) 
      xpath = (u'.//*' + u''.join(((u'[@%s=""%s""]' % c) for c in six.iteritems(clickdata)))) 
      el = form.xpath(xpath) 
      if (len(el) == 1): 
            return (el[0].get('name'), (el[0].get('value') or '')) 
      elif (len(el) > 1): 
            raise ValueError(('Multiple      elements      found      (%r)      matching      the      criteria      in      clickdata:      %r' % (el, clickdata))) 
      else: 
            raise ValueError(('No      clickable      element      matching      clickdata:      %r' % (clickdata,)))","'Returns the clickable element specified in clickdata,   if the latter is given. If not, it returns the first   clickable element found'"
"def parse_cachecontrol(header):
     directives = {} 
      for directive in header.split(','): 
            (key, sep, val) = directive.strip().partition('=') 
            if key: 
                  directives[key.lower()] = (val if sep else None) 
      return directives","'Parse Cache-Control header   http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9   >>> parse_cachecontrol(b\'public, max-age=3600\') == {b\'public\': None,   ...                                                 b\'max-age\': b\'3600\'}   True   >>> parse_cachecontrol(b\'\') == {}   True'"
"def wrap_loader_context(function, context):
     if ('loader_context' in get_func_args(function)): 
            return partial(function, loader_context=context) 
      else: 
            return function","'Wrap functions that receive loader_context to contain the context   ""pre-loaded"" and expose a interface that receives only one argument'"
"def clean_link(link_text):
     return link_text.strip(' DCTB \r\n      \'""\x0c')",'Remove leading and trailing whitespace and punctuation'
"def failure_to_exc_info(failure):
     if isinstance(failure, Failure): 
            return (failure.type, failure.value, failure.getTracebackObject())",'Extract exc_info from Failure instances'
"def configure_logging(settings=None, install_root_handler=True):
     if (not sys.warnoptions): 
            logging.captureWarnings(True) 
      observer = twisted_log.PythonLoggingObserver('twisted') 
      observer.start() 
      dictConfig(DEFAULT_LOGGING) 
      if (isinstance(settings, dict) or (settings is None)): 
            settings = Settings(settings) 
      if settings.getbool('LOG_STDOUT'): 
            sys.stdout = StreamLogger(logging.getLogger('stdout')) 
      if install_root_handler: 
            install_scrapy_root_handler(settings)","'Initialize logging defaults for Scrapy.   :param settings: settings used to create and configure a handler for the   root logger (default: None).   :type settings: dict, :class:`~scrapy.settings.Settings` object or ``None``   :param install_root_handler: whether to install root logging handler   (default: True)   :type install_root_handler: bool   This function does:   - Route warnings and twisted logging through Python standard logging   - Assign DEBUG and ERROR level to Scrapy and Twisted loggers respectively   - Route stdout to log if LOG_STDOUT setting is True   When ``install_root_handler`` is True (default), this function also   creates a handler for the root logger according to given settings   (see :ref:`topics-logging-settings`). You can override default options   using ``settings`` argument. When ``settings`` is empty or None, defaults   are used.'"
"def _get_handler(settings):
     filename = settings.get('LOG_FILE') 
      if filename: 
            encoding = settings.get('LOG_ENCODING') 
            handler = logging.FileHandler(filename, encoding=encoding) 
      elif settings.getbool('LOG_ENABLED'): 
            handler = logging.StreamHandler() 
      else: 
            handler = logging.NullHandler() 
      formatter = logging.Formatter(fmt=settings.get('LOG_FORMAT'), datefmt=settings.get('LOG_DATEFORMAT')) 
      handler.setFormatter(formatter) 
      handler.setLevel(settings.get('LOG_LEVEL')) 
      if settings.getbool('LOG_SHORT_NAMES'): 
            handler.addFilter(TopLevelFormatter(['scrapy'])) 
      return handler",'Return a log handler object according to settings'
"def logformatter_adapter(logkws):
     if (not ({'level', 'msg', 'args'} <= set(logkws))): 
            warnings.warn('Missing      keys      in      LogFormatter      method', ScrapyDeprecationWarning) 
      if ('format' in logkws): 
            warnings.warn('`format`      key      in      LogFormatter      methods      has      been      deprecated,      use      `msg`      instead', ScrapyDeprecationWarning) 
      level = logkws.get('level', logging.INFO) 
      message = logkws.get('format', logkws.get('msg')) 
      args = (logkws if (not logkws.get('args')) else logkws['args']) 
      return (level, message, args)","'Helper that takes the dictionary output from the methods in LogFormatter   and adapts it into a tuple of positional arguments for logger.log calls,   handling backward compatibility as well.'"
"def get_engine_status(engine):
     tests = ['time()-engine.start_time', 'engine.has_capacity()', 'len(engine.downloader.active)', 'engine.scraper.is_idle()', 'engine.spider.name', 'engine.spider_is_idle(engine.spider)', 'engine.slot.closing', 'len(engine.slot.inprogress)', 'len(engine.slot.scheduler.dqs      or      [])', 'len(engine.slot.scheduler.mqs)', 'len(engine.scraper.slot.queue)', 'len(engine.scraper.slot.active)', 'engine.scraper.slot.active_size', 'engine.scraper.slot.itemproc_size', 'engine.scraper.slot.needs_backout()'] 
      checks = [] 
      for test in tests: 
            try: 
                  checks += [(test, eval(test))] 
            except Exception as e: 
                  checks += [(test, ('%s      (exception)' % type(e).__name__))] 
      return checks",'Return a report of the current engine status'
"def assert_aws_environ():
     skip_if_no_boto() 
      if ('AWS_ACCESS_KEY_ID' not in os.environ): 
            raise SkipTest('AWS      keys      not      found')",'Asserts the current environment is suitable for running AWS testsi.   Raises SkipTest with the reason if it\'s not.'
"def get_s3_content_and_delete(bucket, path, with_key=False):
     if is_botocore(): 
            import botocore.session 
            session = botocore.session.get_session() 
            client = session.create_client('s3') 
            key = client.get_object(Bucket=bucket, Key=path) 
            content = key['Body'].read() 
            client.delete_object(Bucket=bucket, Key=path) 
      else: 
            import boto 
            bucket = boto.connect_s3().get_bucket(bucket, validate=False) 
            key = bucket.get_key(path) 
            content = key.get_contents_as_string() 
            bucket.delete_key(path) 
      return ((content, key) if with_key else content)","'Get content from s3 key, and delete key afterwards.'"
"def get_crawler(spidercls=None, settings_dict=None):
     from scrapy.crawler import CrawlerRunner 
      from scrapy.spiders import Spider 
      runner = CrawlerRunner(settings_dict) 
      return runner.create_crawler((spidercls or Spider))","'Return an unconfigured Crawler object. If settings_dict is given, it   will be used to populate the crawler settings with a project level   priority.'"
"def get_pythonpath():
     scrapy_path = import_module('scrapy').__path__[0] 
      return ((os.path.dirname(scrapy_path) + os.pathsep) + os.environ.get('PYTHONPATH', ''))",'Return a PYTHONPATH suitable to use in processes so that they find this   installation of Scrapy'
"def get_testenv():
     env = os.environ.copy() 
      env['PYTHONPATH'] = get_pythonpath() 
      return env","'Return a OS environment dict suitable to fork processes that need to import   this installation of Scrapy, instead of a system installed one.'"
"def assert_samelines(testcase, text1, text2, msg=None):
     testcase.assertEqual(text1.splitlines(), text2.splitlines(), msg)","'Asserts text1 and text2 have the same lines, ignoring differences in   line endings between platforms'"
"def _embed_ipython_shell(namespace={}, banner=''):
     try: 
            from IPython.terminal.embed import InteractiveShellEmbed 
            from IPython.terminal.ipapp import load_default_config 
      except ImportError: 
            from IPython.frontend.terminal.embed import InteractiveShellEmbed 
            from IPython.frontend.terminal.ipapp import load_default_config 
      @wraps(_embed_ipython_shell) 
      def wrapper(namespace=namespace, banner=''): 
            config = load_default_config() 
            InteractiveShellEmbed.clear_instance() 
            shell = InteractiveShellEmbed.instance(banner1=banner, user_ns=namespace, config=config) 
            shell() 
      return wrapper",'Start an IPython Shell'
"def _embed_bpython_shell(namespace={}, banner=''):
     import bpython 
      @wraps(_embed_bpython_shell) 
      def wrapper(namespace=namespace, banner=''): 
            bpython.embed(locals_=namespace, banner=banner) 
      return wrapper",'Start a bpython shell'
"def _embed_ptpython_shell(namespace={}, banner=''):
     import ptpython.repl 
      @wraps(_embed_ptpython_shell) 
      def wrapper(namespace=namespace, banner=''): 
            print banner 
            ptpython.repl.embed(locals=namespace) 
      return wrapper",'Start a ptpython shell'
"def _embed_standard_shell(namespace={}, banner=''):
     import code 
      try: 
            import readline 
      except ImportError: 
            pass 
      else: 
            import rlcompleter 
            readline.parse_and_bind('tab:complete') 
      @wraps(_embed_standard_shell) 
      def wrapper(namespace=namespace, banner=''): 
            code.interact(banner=banner, local=namespace) 
      return wrapper",'Start a standard python shell'
"def get_shell_embed_func(shells=None, known_shells=None):
     if (shells is None): 
            shells = DEFAULT_PYTHON_SHELLS.keys() 
      if (known_shells is None): 
            known_shells = DEFAULT_PYTHON_SHELLS.copy() 
      for shell in shells: 
            if (shell in known_shells): 
                  try: 
                        return known_shells[shell]() 
                  except ImportError: 
                        continue",'Return the first acceptable shell-embed function   from a given list of shell names.'
"def start_python_console(namespace=None, banner='', shells=None):
     if (namespace is None): 
            namespace = {} 
      try: 
            shell = get_shell_embed_func(shells) 
            if (shell is not None): 
                  shell(namespace=namespace, banner=banner) 
      except SystemExit: 
            pass","'Start Python console bound to the given namespace.   Readline support and tab completion will be used on Unix, if available.'"
"def get_base_url(response):
     if (response not in _baseurl_cache): 
            text = response.text[0:4096] 
            _baseurl_cache[response] = html.get_base_url(text, response.url, response.encoding) 
      return _baseurl_cache[response]","'Return the base url of the given response, joined with the response url'"
"def get_meta_refresh(response):
     if (response not in _metaref_cache): 
            text = response.text[0:4096] 
            _metaref_cache[response] = html.get_meta_refresh(text, response.url, response.encoding, ignore_tags=('script', 'noscript')) 
      return _metaref_cache[response]",'Parse the http-equiv refrsh parameter from the given response'
"def response_status_message(status):
     message = http.RESPONSES.get(int(status), 'Unknown      Status') 
      return ('%s      %s' % (status, to_native_str(message)))",'Return status code plus status text descriptive message'
"def response_httprepr(response):
     s = (((('HTTP/1.1      ' + to_bytes(str(response.status))) + '      ') + to_bytes(http.RESPONSES.get(response.status, ''))) + '\r\n') 
      if response.headers: 
            s += (response.headers.to_string() + '\r\n') 
      s += '\r\n' 
      s += response.body 
      return s","'Return raw HTTP representation (as bytes) of the given response. This   is provided only for reference, since it\'s not the exact stream of bytes   that was received (that\'s not exposed by Twisted).'"
"def open_in_browser(response, _openfunc=webbrowser.open):
     from scrapy.http import HtmlResponse, TextResponse 
      body = response.body 
      if isinstance(response, HtmlResponse): 
            if ('<base' not in body): 
                  repl = ('<head><base      href=""%s"">' % response.url) 
                  body = body.replace('<head>', to_bytes(repl)) 
            ext = '.html' 
      elif isinstance(response, TextResponse): 
            ext = '.txt' 
      else: 
            raise TypeError(('Unsupported      response      type:      %s' % response.__class__.__name__)) 
      (fd, fname) = tempfile.mkstemp(ext) 
      os.write(fd, body) 
      os.close(fd) 
      return _openfunc(('file://%s' % fname))","'Open the given response in a local web browser, populating the <base>   tag for external links to work'"
"def send_catch_log(signal=Any, sender=Anonymous, *arguments, **named):
     dont_log = named.pop('dont_log', _IgnoredException) 
      spider = named.get('spider', None) 
      responses = [] 
      for receiver in liveReceivers(getAllReceivers(sender, signal)): 
            try: 
                  response = robustApply(receiver, signal=signal, sender=sender, *arguments, **named) 
                  if isinstance(response, Deferred): 
                        logger.error('Cannot      return      deferreds      from      signal      handler:      %(receiver)s', {'receiver': receiver}, extra={'spider': spider}) 
            except dont_log: 
                  result = Failure() 
            except Exception: 
                  result = Failure() 
                  logger.error('Error      caught      on      signal      handler:      %(receiver)s', {'receiver': receiver}, exc_info=True, extra={'spider': spider}) 
            else: 
                  result = response 
            responses.append((receiver, result)) 
      return responses",'Like pydispatcher.robust.sendRobust but it also logs errors and returns   Failures instead of exceptions.'
"def send_catch_log_deferred(signal=Any, sender=Anonymous, *arguments, **named):
     def logerror(failure, recv): 
            if ((dont_log is None) or (not isinstance(failure.value, dont_log))): 
                  logger.error('Error      caught      on      signal      handler:      %(receiver)s', {'receiver': recv}, exc_info=failure_to_exc_info(failure), extra={'spider': spider}) 
            return failure 
      dont_log = named.pop('dont_log', None) 
      spider = named.get('spider', None) 
      dfds = [] 
      for receiver in liveReceivers(getAllReceivers(sender, signal)): 
            d = maybeDeferred(robustApply, receiver, signal=signal, sender=sender, *arguments, **named) 
            d.addErrback(logerror, receiver) 
            d.addBoth((lambda result: (receiver, result))) 
            dfds.append(d) 
      d = DeferredList(dfds) 
      d.addCallback((lambda out: [x[1] for x in out])) 
      return d",'Like send_catch_log but supports returning deferreds on signal handlers.   Returns a deferred that gets fired once all signal handlers deferreds were   fired.'
"def disconnect_all(signal=Any, sender=Any):
     for receiver in liveReceivers(getAllReceivers(sender, signal)): 
            disconnect(receiver, signal=signal, sender=sender)",'Disconnect all signal handlers. Useful for cleaning up after running   tests'
"def iter_spider_classes(module):
     from scrapy.spiders import Spider 
      for obj in six.itervalues(vars(module)): 
            if (inspect.isclass(obj) and issubclass(obj, Spider) and (obj.__module__ == module.__name__) and getattr(obj, 'name', None)): 
                  (yield obj)",'Return an iterator over all spider classes defined in the given module   that can be instantiated (ie. which have name)'
"def spidercls_for_request(spider_loader, request, default_spidercls=None, log_none=False, log_multiple=False):
     snames = spider_loader.find_by_request(request) 
      if (len(snames) == 1): 
            return spider_loader.load(snames[0]) 
      if ((len(snames) > 1) and log_multiple): 
            logger.error('More      than      one      spider      can      handle:      %(request)s      -      %(snames)s', {'request': request, 'snames': ',      '.join(snames)}) 
      if ((len(snames) == 0) and log_none): 
            logger.error('Unable      to      find      spider      that      handles:      %(request)s', {'request': request}) 
      return default_spidercls","'Return a spider class that handles the given Request.   This will look for the spiders that can handle the given request (using   the spider loader) and return a Spider class if (and only if) there is   only one Spider able to handle the Request.   If multiple spiders (or no spider) are found, it will return the   default_spidercls passed. It can optionally log if multiple or no spiders   are found.'"
"def format_live_refs(ignore=NoneType):
     s = 'Live      References\n\n' 
      now = time() 
      for (cls, wdict) in sorted(six.iteritems(live_refs), key=(lambda x: x[0].__name__)): 
            if (not wdict): 
                  continue 
            if issubclass(cls, ignore): 
                  continue 
            oldest = min(six.itervalues(wdict)) 
            s += ('%-30s      %6d                  oldest:      %ds      ago\n' % (cls.__name__, len(wdict), (now - oldest))) 
      return s",'Return a tabular representation of tracked objects'
"def print_live_refs(*a, **kw):
     print(format_live_refs(*a, **kw))",'Print tracked objects'
"def get_oldest(class_name):
     for (cls, wdict) in six.iteritems(live_refs): 
            if (cls.__name__ == class_name): 
                  if (not wdict): 
                        break 
                  return min(six.iteritems(wdict), key=itemgetter(1))[0]",'Get the oldest object for a specific class name'
